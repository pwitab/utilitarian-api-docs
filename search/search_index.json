{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Utilitarian Documentation # Welcome to the Utilitarian documentation. Utilitarian is a multi utility AMR (Automatic Meter Reading) tool system that gives you and your organisation a simple way to manager AMR operations over multiple energy medias, protocol and metering equipment. In this documentation we we cover everything about the product and our on-premise offerings. Get started # To get a better grip on how Utilitarian and all its component works together check out the Architecture page. If you are interested in what type of communication protocols we support go to the Protocols page. We are continuously adding new meters that we support, and even if we haven't tried out your meters yet we might already support them due to out general protocol interpreters, or we need to do some work to get them into the system. To get info on the meters we have already verified against Utilitarian go to the meters page and if you need custom work done please contact us . As of now we are offering Utilitarian as an on-premise services. Our client base of utility companies usually prefer it this way. But keep a look out for the managed cloud version of Utilitarian. To know more about how to run Utilitarian check out the installation page. Get in contact # Simplest way of getting in contact with us is via email: info@pwit.se","title":"Home"},{"location":"#utilitarian-documentation","text":"Welcome to the Utilitarian documentation. Utilitarian is a multi utility AMR (Automatic Meter Reading) tool system that gives you and your organisation a simple way to manager AMR operations over multiple energy medias, protocol and metering equipment. In this documentation we we cover everything about the product and our on-premise offerings.","title":"Utilitarian Documentation"},{"location":"#get-started","text":"To get a better grip on how Utilitarian and all its component works together check out the Architecture page. If you are interested in what type of communication protocols we support go to the Protocols page. We are continuously adding new meters that we support, and even if we haven't tried out your meters yet we might already support them due to out general protocol interpreters, or we need to do some work to get them into the system. To get info on the meters we have already verified against Utilitarian go to the meters page and if you need custom work done please contact us . As of now we are offering Utilitarian as an on-premise services. Our client base of utility companies usually prefer it this way. But keep a look out for the managed cloud version of Utilitarian. To know more about how to run Utilitarian check out the installation page.","title":"Get started"},{"location":"#get-in-contact","text":"Simplest way of getting in contact with us is via email: info@pwit.se","title":"Get in contact"},{"location":"amr_um/","text":"Unified Messaging for Automatic Meter Readings # AMR UM is a project trying to define clearer messages that are focused on AMR operations. In metering it is common to use CIM (IEC 61968) to model your business processes and define messages for different type of operations. But it is all on quite high level. It is also a bit ambiguous how to use the models. There are several possiblities for the DSO (Distribution System Operators) to model the same data so focusing to comply with CIM in messages within Utilitarian would not be beneficial. Instead we are focusing on making clearly defined messages and document the usage well. We will if needed, provide translation services for CIM or other formats. But as of now it is up to the user to hook in to the message stream and get the data they need. We plan on sending all messages serialized using Avro and have a schema server for deserialization so that we can handle versioning of schemas. But this is a work in progress and for now we send messages in json format. We have developed a helper library in Python to build objects and make payloads for AMR UM messages: Check it out on GitHub Message Types # DLMS Push Message # Contains a push message (DataNotification) from a DLMS Meter { \"payload\" : \"base64encodedbytes\" , \"transport\" : \"udp\" , \"source_address\" : 'ip_address_of_origin' , \"source_port\" : 5678 , \"application_context\" : \"dsmr\" , \"dlms_wrapper\" : { \"source_wport\" : 1 , \"destiniation_wport\" : 10 , \"version\" : 1 } } New Meter Reading # Message containing a single meter reading { \"meter\" : \"FIOR78464920374\" , \"series\" : \"7-0-13-26-0-101\" , \"timestamp\" : \"2019-02-24T06:00:00T+01:00\" , \"value\" : \"14567.000\" }","title":"Messaging"},{"location":"amr_um/#unified-messaging-for-automatic-meter-readings","text":"AMR UM is a project trying to define clearer messages that are focused on AMR operations. In metering it is common to use CIM (IEC 61968) to model your business processes and define messages for different type of operations. But it is all on quite high level. It is also a bit ambiguous how to use the models. There are several possiblities for the DSO (Distribution System Operators) to model the same data so focusing to comply with CIM in messages within Utilitarian would not be beneficial. Instead we are focusing on making clearly defined messages and document the usage well. We will if needed, provide translation services for CIM or other formats. But as of now it is up to the user to hook in to the message stream and get the data they need. We plan on sending all messages serialized using Avro and have a schema server for deserialization so that we can handle versioning of schemas. But this is a work in progress and for now we send messages in json format. We have developed a helper library in Python to build objects and make payloads for AMR UM messages: Check it out on GitHub","title":"Unified Messaging for Automatic Meter Readings"},{"location":"amr_um/#message-types","text":"","title":"Message Types"},{"location":"amr_um/#dlms-push-message","text":"Contains a push message (DataNotification) from a DLMS Meter { \"payload\" : \"base64encodedbytes\" , \"transport\" : \"udp\" , \"source_address\" : 'ip_address_of_origin' , \"source_port\" : 5678 , \"application_context\" : \"dsmr\" , \"dlms_wrapper\" : { \"source_wport\" : 1 , \"destiniation_wport\" : 10 , \"version\" : 1 } }","title":"DLMS Push Message"},{"location":"amr_um/#new-meter-reading","text":"Message containing a single meter reading { \"meter\" : \"FIOR78464920374\" , \"series\" : \"7-0-13-26-0-101\" , \"timestamp\" : \"2019-02-24T06:00:00T+01:00\" , \"value\" : \"14567.000\" }","title":"New Meter Reading"},{"location":"architecture/","text":"Architecture # About architecture TODO","title":"Overview"},{"location":"architecture/#architecture","text":"About architecture TODO","title":"Architecture"},{"location":"component_settings/","text":"Component Settings # Our docker images are handed settings via Environment Variables Utilitarian API # UTILITARIAN_DEBUG # Enables debugging features. Defaults to False . Warning Do not use in production! UTILITARIAN_LOGLEVEL # Sets the loglevel of the application. Valid inputs are: debug , info , warning , error , critical . Defaults to info DATABASE_URL # Connection string to Postgres database. SECRET_KEY # Used for internal cryptographic signing and cryptographic methods. Should be generated once at first deploy time. Recommended length is 50 characters. Warning The SECRET_KEY plays an important role in securing the application. Make sure it remains secret. ALLOWED_HOSTS # A list of allowed host for the application. The application will only accept requests with a host in this list. Example: example.com, 127.0.0.1 . ACCOUNT_ALLOW_REGISTRATION # If you want to allow user registration in the application. Defaults to False . AMQP_CONNECTION_STRING # AMQP Connection string to RabbitMQ broker. Example: amqp://guest:guest@rabbitmq:5672// . AMQP_PUBLISH_TO # RabbitMQ exchange where messages from Utilitarian API is published. SECURE_SSL_REDIRECT # It is better to use DNS or a reverse proxy for this functionality but if that is not possible setting to True will redirect all non HTTPS requests to HTTPS. Defaults to False . SECURE_HSTS_SECONDS # If set to a non-zero integer value the application will set the HTTP Strict Transport Security header on all responses that do not already have it. This will tell browsers and clients that the application is only to be served under HTTPS. When enabling you should always set to a low value (60) and increase it after it works. Defaults to 0 . Warning Using this setting wrongly can make your application unaccessable for quite some time. Please see the full documentation of this feature before doing any changes. SECURE_HSTS_INCLUDE_SUBDOMAINS # Enable if SECURE_HSTS_SECONDS should include all subdomains too. It will not take affect unless the SECURE_HST_SECONDS are set to a non zero value. Defaults to False . SECURE_CONTENT_TYPE_NOSNIFF # If True, Utilitarian API sets the X-Content-Type-Options: nosniff header on all responses that do not already have it. Defaults to True . SECURE_BROWSER_XSS_FILTER # If True, Utilitarian API sets the X-XSS-Protection: 1; mode=block header on all responses that do not already have it. Defaults to True . SESSION_COOKIE_SECURE # Whether to use a secure cookie for the session cookie. If this is set to True, the cookie will be marked as \u201csecure,\u201d which means browsers may ensure that the cookie is only sent under an HTTPS connection. Defaults to True . CSRF_COOKIE_SECURE # Whether to use a secure cookie for the CSRF cookie. If this is set to True, the cookie will be marked as \u201csecure,\u201d which means browsers may ensure that the cookie is only sent under an HTTPS connection. Defaults to True . USE_X_FORWARDED_HOST # A boolean that specifies whether to use the X-Forwarded-Host header in preference to the Host header. This should only be enabled if a proxy which sets this header is in use. This setting takes priority over USE_X_FORWARDED_PORT. Per RFC 7239#page-7 , the X-Forwarded-Host header can include the port number, in which case you shouldn\u2019t use USE_X_FORWARDED_PORT. Defaults to False . USE_X_FORWARDED_HOST # A boolean that specifies whether to use the X-Forwarded-Port header in preference to the SERVER_PORT META variable. This should only be enabled if a proxy which sets this header is in use. USE_X_FORWARDED_HOST takes priority over this setting. USE_X_FORWARDED_PROTO # X-Forwarded-Proto header that comes from our proxy, and any time its value is 'https', then the request is guaranteed to be secure (i.e., it originally came in via HTTPS). You should only set this setting if you control your proxy or have some other guarantee that it sets/strips this header appropriately Defaults to False Warning Modifying this setting can compromise your Utilitarian API\u2019s security. Ensure you fully understand your setup before changing it. Make sure ALL of the following are true before setting this (assuming the values from the example above): Your Utilitarian API is behind a proxy. Your proxy strips the X-Forwarded-Proto header from all incoming requests. In other words, if end users include that header in their requests, the proxy will discard it. Your proxy sets the X-Forwarded-Proto header and sends it to Utilitarian API, but only for requests that originally come in via HTTPS. If any of those are not true, you should keep this setting set to False. UTILITARIAN_TIME_ZONE # Local time zone for this installation. Choices can be found here: http://en.wikipedia.org/wiki/List_of_tz_zones_by_name although not all choices may be available on all operating systems. Utilitarian still handles all datetimes as time zone aware internally. Defaults to 'UTC' DLMS UDP Server # LOGLEVEL DLMS PROCESSOR # LOGLEVEL Utilitarian Poster #","title":"Component Configuration"},{"location":"component_settings/#component-settings","text":"Our docker images are handed settings via Environment Variables","title":"Component Settings"},{"location":"component_settings/#utilitarian-api","text":"","title":"Utilitarian API"},{"location":"component_settings/#utilitarian_debug","text":"Enables debugging features. Defaults to False . Warning Do not use in production!","title":"UTILITARIAN_DEBUG"},{"location":"component_settings/#utilitarian_loglevel","text":"Sets the loglevel of the application. Valid inputs are: debug , info , warning , error , critical . Defaults to info","title":"UTILITARIAN_LOGLEVEL"},{"location":"component_settings/#database_url","text":"Connection string to Postgres database.","title":"DATABASE_URL"},{"location":"component_settings/#secret_key","text":"Used for internal cryptographic signing and cryptographic methods. Should be generated once at first deploy time. Recommended length is 50 characters. Warning The SECRET_KEY plays an important role in securing the application. Make sure it remains secret.","title":"SECRET_KEY"},{"location":"component_settings/#allowed_hosts","text":"A list of allowed host for the application. The application will only accept requests with a host in this list. Example: example.com, 127.0.0.1 .","title":"ALLOWED_HOSTS"},{"location":"component_settings/#account_allow_registration","text":"If you want to allow user registration in the application. Defaults to False .","title":"ACCOUNT_ALLOW_REGISTRATION"},{"location":"component_settings/#amqp_connection_string","text":"AMQP Connection string to RabbitMQ broker. Example: amqp://guest:guest@rabbitmq:5672// .","title":"AMQP_CONNECTION_STRING"},{"location":"component_settings/#amqp_publish_to","text":"RabbitMQ exchange where messages from Utilitarian API is published.","title":"AMQP_PUBLISH_TO"},{"location":"component_settings/#secure_ssl_redirect","text":"It is better to use DNS or a reverse proxy for this functionality but if that is not possible setting to True will redirect all non HTTPS requests to HTTPS. Defaults to False .","title":"SECURE_SSL_REDIRECT"},{"location":"component_settings/#secure_hsts_seconds","text":"If set to a non-zero integer value the application will set the HTTP Strict Transport Security header on all responses that do not already have it. This will tell browsers and clients that the application is only to be served under HTTPS. When enabling you should always set to a low value (60) and increase it after it works. Defaults to 0 . Warning Using this setting wrongly can make your application unaccessable for quite some time. Please see the full documentation of this feature before doing any changes.","title":"SECURE_HSTS_SECONDS"},{"location":"component_settings/#secure_hsts_include_subdomains","text":"Enable if SECURE_HSTS_SECONDS should include all subdomains too. It will not take affect unless the SECURE_HST_SECONDS are set to a non zero value. Defaults to False .","title":"SECURE_HSTS_INCLUDE_SUBDOMAINS"},{"location":"component_settings/#secure_content_type_nosniff","text":"If True, Utilitarian API sets the X-Content-Type-Options: nosniff header on all responses that do not already have it. Defaults to True .","title":"SECURE_CONTENT_TYPE_NOSNIFF"},{"location":"component_settings/#secure_browser_xss_filter","text":"If True, Utilitarian API sets the X-XSS-Protection: 1; mode=block header on all responses that do not already have it. Defaults to True .","title":"SECURE_BROWSER_XSS_FILTER"},{"location":"component_settings/#session_cookie_secure","text":"Whether to use a secure cookie for the session cookie. If this is set to True, the cookie will be marked as \u201csecure,\u201d which means browsers may ensure that the cookie is only sent under an HTTPS connection. Defaults to True .","title":"SESSION_COOKIE_SECURE"},{"location":"component_settings/#csrf_cookie_secure","text":"Whether to use a secure cookie for the CSRF cookie. If this is set to True, the cookie will be marked as \u201csecure,\u201d which means browsers may ensure that the cookie is only sent under an HTTPS connection. Defaults to True .","title":"CSRF_COOKIE_SECURE"},{"location":"component_settings/#use_x_forwarded_host","text":"A boolean that specifies whether to use the X-Forwarded-Host header in preference to the Host header. This should only be enabled if a proxy which sets this header is in use. This setting takes priority over USE_X_FORWARDED_PORT. Per RFC 7239#page-7 , the X-Forwarded-Host header can include the port number, in which case you shouldn\u2019t use USE_X_FORWARDED_PORT. Defaults to False .","title":"USE_X_FORWARDED_HOST"},{"location":"component_settings/#use_x_forwarded_host_1","text":"A boolean that specifies whether to use the X-Forwarded-Port header in preference to the SERVER_PORT META variable. This should only be enabled if a proxy which sets this header is in use. USE_X_FORWARDED_HOST takes priority over this setting.","title":"USE_X_FORWARDED_HOST"},{"location":"component_settings/#use_x_forwarded_proto","text":"X-Forwarded-Proto header that comes from our proxy, and any time its value is 'https', then the request is guaranteed to be secure (i.e., it originally came in via HTTPS). You should only set this setting if you control your proxy or have some other guarantee that it sets/strips this header appropriately Defaults to False Warning Modifying this setting can compromise your Utilitarian API\u2019s security. Ensure you fully understand your setup before changing it. Make sure ALL of the following are true before setting this (assuming the values from the example above): Your Utilitarian API is behind a proxy. Your proxy strips the X-Forwarded-Proto header from all incoming requests. In other words, if end users include that header in their requests, the proxy will discard it. Your proxy sets the X-Forwarded-Proto header and sends it to Utilitarian API, but only for requests that originally come in via HTTPS. If any of those are not true, you should keep this setting set to False.","title":"USE_X_FORWARDED_PROTO"},{"location":"component_settings/#utilitarian_time_zone","text":"Local time zone for this installation. Choices can be found here: http://en.wikipedia.org/wiki/List_of_tz_zones_by_name although not all choices may be available on all operating systems. Utilitarian still handles all datetimes as time zone aware internally. Defaults to 'UTC'","title":"UTILITARIAN_TIME_ZONE"},{"location":"component_settings/#dlms-udp-server","text":"LOGLEVEL","title":"DLMS UDP Server"},{"location":"component_settings/#dlms-processor","text":"LOGLEVEL","title":"DLMS PROCESSOR"},{"location":"component_settings/#utilitarian-poster","text":"","title":"Utilitarian Poster"},{"location":"components/","text":"Components in Utilitarian # Utilitarian API # The main application for Utilitarian. It stores all data and handles all scheduling of reading jobs. We provide a REST API to manage the data and jobs. docker pull quay.io/pwitab/utilitarian:version See component settings on how to configure Utilitarian API DLMS UDP Server # A high throughput UDP server to receive DLMS DataNotifications from meters. docker pull quay.io/pwitab/utilitarian-dlms-udp-server:version DLMS Processor # Many DLMS push messages are encrypted and to decrypt UDP messages in the receiving server would reduce throughput and we could loose messages if the server is not available to process them. Instead the UDP server sends the DLMS messages to the message broker and they are consumed by the DLMS Processor where they get decrypted and parsed into Meter Readings that is published back to the message broker. docker pull quay.io/pwitab/utilitarian-dlms-processor:version Utilitarian Poster # The Utilitarian poster is a queue consumer that will receive all data that are to be saved in the Utilitarian API and send it over HTTP to the correct endpoint. docker pull quay.io/pwitab/utilitarian-poster:version Database # Utilitarian uses PostgreSQL as database. Message Broker # Utilitarian uses RabbitMQ as message broker.","title":"Components"},{"location":"components/#components-in-utilitarian","text":"","title":"Components in Utilitarian"},{"location":"components/#utilitarian-api","text":"The main application for Utilitarian. It stores all data and handles all scheduling of reading jobs. We provide a REST API to manage the data and jobs. docker pull quay.io/pwitab/utilitarian:version See component settings on how to configure Utilitarian API","title":"Utilitarian API"},{"location":"components/#dlms-udp-server","text":"A high throughput UDP server to receive DLMS DataNotifications from meters. docker pull quay.io/pwitab/utilitarian-dlms-udp-server:version","title":"DLMS UDP Server"},{"location":"components/#dlms-processor","text":"Many DLMS push messages are encrypted and to decrypt UDP messages in the receiving server would reduce throughput and we could loose messages if the server is not available to process them. Instead the UDP server sends the DLMS messages to the message broker and they are consumed by the DLMS Processor where they get decrypted and parsed into Meter Readings that is published back to the message broker. docker pull quay.io/pwitab/utilitarian-dlms-processor:version","title":"DLMS Processor"},{"location":"components/#utilitarian-poster","text":"The Utilitarian poster is a queue consumer that will receive all data that are to be saved in the Utilitarian API and send it over HTTP to the correct endpoint. docker pull quay.io/pwitab/utilitarian-poster:version","title":"Utilitarian Poster"},{"location":"components/#database","text":"Utilitarian uses PostgreSQL as database.","title":"Database"},{"location":"components/#message-broker","text":"Utilitarian uses RabbitMQ as message broker.","title":"Message Broker"},{"location":"docker_compose/","text":"Setting up with docker-compose # docker-compose Install docker-compose # Easiest is to use pip pip install docker-compose Define docker-compose file # Create a new docker-compose.yaml file touch docker-compose.yaml Define all services with environment variables and volumes if needed. Note We are using docker containers for Postgres and RabbitMQ just to show the system as a whole. You don't need to run them in containers, as we except just the connection string as input to the other services. # Example docker compose containers for Utiltarian version : '3' services : rabbitmq : image : rabbitmq:3-management restart : unless-stopped ports : - \"5672:5672\" - \"15672:15672\" postgres : image : postgres:10.7-apline restart : unless-stopped ports : - \"15432:5432\" volumes : - postgres_data:/var/lib/postgresql/data/ utilitarian_api : image : quay.io/pwitab/utilitarian:vx.x.x restart : unless-stopped ports : - \"8000:8000\" depends_on : - rabbitmq - postres environment : # Debug # SECURITY WARNING: Don't use in production - UTILITARIAN_DEBUG=false - UTILITARIAN_LOGLEVEL=debug - # General settings - DATABASE_URL=postgres://postgres/dbname - SECRET_KEY=verysecretkey - ALLOWED_HOSTS=utilitarian_api dlms_processor : image : quay.io/pwitab/utilitarian-dlms-processor:vX.X.X restart : unless-stopped depends_on : - rabbitmq - utilitarian_api environment : - DLMS_CONSUMER_DEBUG=false - AMQP_CONNECTION_STRING=amqp://guest:guest@rabbitmq:5672// - DLMS_CONSUMER_CONSUME_FROM=utilitarian.dlms_push_messages - DLMS_CONSUMER_PREFETCH_COUNT=100 - DLMS_CONSUMER_PUBLISH_TO=utilitarian - UTILITARIAN_BASE_URL=http://utilitarian_api:8000 - UTILITARIAN_AUTH_TOKEN=024281a8c6a12b5fb5a8445439bb9236555975fe - UTILITARIAN_REQUEST_TIMEOUT=15 dlms_udp_server : image : quay.io/pwitab/utilitarian-dlms-upd-server:vX.X.X restart : unless-stopped ports : # You need to specify that it is an UDP port and not TCP! - '4059:4059/udp' depends_on : - rabbitmq environment : - DLMS_UDP_SERVER_DEBUG=false - AMQP_CONNECTION_STRING=amqp://guest:guest@rabbitmq:5672// - AMQP_EXCHANGE_NAME=utilitarian - AMQP_DEFAULT_QUEUE_NAME=utilitarian.dlms_push_messages - AMQP_DEFAULT_QUEUE_ROUTING_KEY=\"new_dlms_push_message.#\" - UTILITARIAN_APPLICATION_CONTEXT=units11291 utilitarian_poster : image : quay.io/pwitab/utilitarian-poster:vX.X.X restart : unless-stopped depends_on : - rabbitmq - utilitarian_api environment : - POSTER_DEBUG=false - AMQP_CONNECTION_STRING=amqp://guest:guest@rabbitmq:5672// - POSTER_CONSUME_FROM=utilitarian.new_meter_readings - POSTER_PREFETCH_COUNT=100 - UTILITARIAN_BASE_URL=http://utilitarian_api:8000 - UTILITARIAN_AUTH_TOKEN=024281a8c6a12b5fb5a8445439bb9236555975fe - UTILITARIAN_REQUEST_TIMEOUT=15 volumes : - postgres_data :","title":"Setup using Docker Compose"},{"location":"docker_compose/#setting-up-with-docker-compose","text":"docker-compose","title":"Setting up with docker-compose"},{"location":"docker_compose/#install-docker-compose","text":"Easiest is to use pip pip install docker-compose","title":"Install docker-compose"},{"location":"docker_compose/#define-docker-compose-file","text":"Create a new docker-compose.yaml file touch docker-compose.yaml Define all services with environment variables and volumes if needed. Note We are using docker containers for Postgres and RabbitMQ just to show the system as a whole. You don't need to run them in containers, as we except just the connection string as input to the other services. # Example docker compose containers for Utiltarian version : '3' services : rabbitmq : image : rabbitmq:3-management restart : unless-stopped ports : - \"5672:5672\" - \"15672:15672\" postgres : image : postgres:10.7-apline restart : unless-stopped ports : - \"15432:5432\" volumes : - postgres_data:/var/lib/postgresql/data/ utilitarian_api : image : quay.io/pwitab/utilitarian:vx.x.x restart : unless-stopped ports : - \"8000:8000\" depends_on : - rabbitmq - postres environment : # Debug # SECURITY WARNING: Don't use in production - UTILITARIAN_DEBUG=false - UTILITARIAN_LOGLEVEL=debug - # General settings - DATABASE_URL=postgres://postgres/dbname - SECRET_KEY=verysecretkey - ALLOWED_HOSTS=utilitarian_api dlms_processor : image : quay.io/pwitab/utilitarian-dlms-processor:vX.X.X restart : unless-stopped depends_on : - rabbitmq - utilitarian_api environment : - DLMS_CONSUMER_DEBUG=false - AMQP_CONNECTION_STRING=amqp://guest:guest@rabbitmq:5672// - DLMS_CONSUMER_CONSUME_FROM=utilitarian.dlms_push_messages - DLMS_CONSUMER_PREFETCH_COUNT=100 - DLMS_CONSUMER_PUBLISH_TO=utilitarian - UTILITARIAN_BASE_URL=http://utilitarian_api:8000 - UTILITARIAN_AUTH_TOKEN=024281a8c6a12b5fb5a8445439bb9236555975fe - UTILITARIAN_REQUEST_TIMEOUT=15 dlms_udp_server : image : quay.io/pwitab/utilitarian-dlms-upd-server:vX.X.X restart : unless-stopped ports : # You need to specify that it is an UDP port and not TCP! - '4059:4059/udp' depends_on : - rabbitmq environment : - DLMS_UDP_SERVER_DEBUG=false - AMQP_CONNECTION_STRING=amqp://guest:guest@rabbitmq:5672// - AMQP_EXCHANGE_NAME=utilitarian - AMQP_DEFAULT_QUEUE_NAME=utilitarian.dlms_push_messages - AMQP_DEFAULT_QUEUE_ROUTING_KEY=\"new_dlms_push_message.#\" - UTILITARIAN_APPLICATION_CONTEXT=units11291 utilitarian_poster : image : quay.io/pwitab/utilitarian-poster:vX.X.X restart : unless-stopped depends_on : - rabbitmq - utilitarian_api environment : - POSTER_DEBUG=false - AMQP_CONNECTION_STRING=amqp://guest:guest@rabbitmq:5672// - POSTER_CONSUME_FROM=utilitarian.new_meter_readings - POSTER_PREFETCH_COUNT=100 - UTILITARIAN_BASE_URL=http://utilitarian_api:8000 - UTILITARIAN_AUTH_TOKEN=024281a8c6a12b5fb5a8445439bb9236555975fe - UTILITARIAN_REQUEST_TIMEOUT=15 volumes : - postgres_data :","title":"Define docker-compose file"},{"location":"installation/","text":"On Premise # How to install and run Utilitarian Requirements # Utilitarian depends on the following systems: Postgres 10 RabbitMQ Docker # All Utilitarian components are distributed via docker images. When you have purchased a Utilitarian License you will get a login account to be able to fetch the images via docker-cli . As of now all PWIT docker images are stored in Quay and you will need to use the credentials supplied by us to log in and pull the images. $ docker login quay.io Login against server at https://quay.io/v1/ Username: pwitab+yourpullaccount Password: ThePasswordGivenToYouFromPWIT Email: any@example.com Once you have logged in you can pull the images. docker pull quay.io/pwitab/repo-name:version Installation # We will provide information on how to install and run the applications via docker-compose . In the future we will also provide instructions for Kubernetes. Docker compose might not be the right tool to for you depending on your installation and system requirements but it is a good starting point and you will get a lot of insight on how to run the systems via this instruction. If you need assistance running Utilitarian in another environment please contact us . Postgres # We use Postgres as our database of choice. We recommend that you set up Postgres on a dedicated server or use a managed service for it. You can find out a lot about running Postgres online . Also make sure you have proper security settings and follow best practices. If you are running Postgres yourself you also want to set up a stable backup function . After you have set up postgres you will supply the connection string in the format: postgres://[user[:password]@][host][:port][,...][/dbname][?param1=value1&...] # Example postgres://myuser:mysecretpassword@localhost:5432/db_name Postgres is available as a docker container and if you also want to run Postgres via docker make sure you set up a volume for it so that you don't loose any of your data. docker pull postgres:10.7-alpine RabbitMQ # RabbitMQ is a message broker for the AMQP protocol. Utilitarian uses it for inter-application communication and data processing. Checkout the official RabbitMQ site to learn how to run RabbitMQ or purchase a managed solution from, for example CloudAMQP . You will need to provide a similar connection string for RabbitMQ as for Postgres: amqp://[user[:password]@][host][:port][/vhost]] # Example amqp://guest:guest@localhost:5672// RabbitMQ can also be run as a container. Just be sure to add a volume for it so you don't loose any data and we recommend that you include the management plugin so that you have an interface for management and debugging if something is not working correctly. docker pull rabbitmq:3.7.13-management-alpine Hardware # We don\u2019t have any real numbers to tell you what kind of hardware you\u2019re going to need, but we\u2019ll help you make your decision based on existing usage from real customers. It all depends on how many meters you are managing in Utilitarian and how much data you collect from them. If you have a wide range of different meters you must also take into consideration that you will have multiple services of different kinds running in your environment. We provide means to scale horizontally but the database is still the single point of failure. Since you are free to set up the database the way your IT department or Ops team requires we leave this implementation detail to the customer. Monitoring # We do not supply a standard solution to monitor the applications. All logs from the different applications are outputed on stdout via docker. So they are accessible via docker logs. You can then hook up the docker logs to different logging drivers, see the official docker documentation . There are several solutions to application and log monitoring. For example Elastic Stack or Splunk. Contact us if you want help setting this up for your installation.","title":"Installation"},{"location":"installation/#on-premise","text":"How to install and run Utilitarian","title":"On Premise"},{"location":"installation/#requirements","text":"Utilitarian depends on the following systems: Postgres 10 RabbitMQ","title":"Requirements"},{"location":"installation/#docker","text":"All Utilitarian components are distributed via docker images. When you have purchased a Utilitarian License you will get a login account to be able to fetch the images via docker-cli . As of now all PWIT docker images are stored in Quay and you will need to use the credentials supplied by us to log in and pull the images. $ docker login quay.io Login against server at https://quay.io/v1/ Username: pwitab+yourpullaccount Password: ThePasswordGivenToYouFromPWIT Email: any@example.com Once you have logged in you can pull the images. docker pull quay.io/pwitab/repo-name:version","title":"Docker"},{"location":"installation/#installation","text":"We will provide information on how to install and run the applications via docker-compose . In the future we will also provide instructions for Kubernetes. Docker compose might not be the right tool to for you depending on your installation and system requirements but it is a good starting point and you will get a lot of insight on how to run the systems via this instruction. If you need assistance running Utilitarian in another environment please contact us .","title":"Installation"},{"location":"installation/#postgres","text":"We use Postgres as our database of choice. We recommend that you set up Postgres on a dedicated server or use a managed service for it. You can find out a lot about running Postgres online . Also make sure you have proper security settings and follow best practices. If you are running Postgres yourself you also want to set up a stable backup function . After you have set up postgres you will supply the connection string in the format: postgres://[user[:password]@][host][:port][,...][/dbname][?param1=value1&...] # Example postgres://myuser:mysecretpassword@localhost:5432/db_name Postgres is available as a docker container and if you also want to run Postgres via docker make sure you set up a volume for it so that you don't loose any of your data. docker pull postgres:10.7-alpine","title":"Postgres"},{"location":"installation/#rabbitmq","text":"RabbitMQ is a message broker for the AMQP protocol. Utilitarian uses it for inter-application communication and data processing. Checkout the official RabbitMQ site to learn how to run RabbitMQ or purchase a managed solution from, for example CloudAMQP . You will need to provide a similar connection string for RabbitMQ as for Postgres: amqp://[user[:password]@][host][:port][/vhost]] # Example amqp://guest:guest@localhost:5672// RabbitMQ can also be run as a container. Just be sure to add a volume for it so you don't loose any data and we recommend that you include the management plugin so that you have an interface for management and debugging if something is not working correctly. docker pull rabbitmq:3.7.13-management-alpine","title":"RabbitMQ"},{"location":"installation/#hardware","text":"We don\u2019t have any real numbers to tell you what kind of hardware you\u2019re going to need, but we\u2019ll help you make your decision based on existing usage from real customers. It all depends on how many meters you are managing in Utilitarian and how much data you collect from them. If you have a wide range of different meters you must also take into consideration that you will have multiple services of different kinds running in your environment. We provide means to scale horizontally but the database is still the single point of failure. Since you are free to set up the database the way your IT department or Ops team requires we leave this implementation detail to the customer.","title":"Hardware"},{"location":"installation/#monitoring","text":"We do not supply a standard solution to monitor the applications. All logs from the different applications are outputed on stdout via docker. So they are accessible via docker logs. You can then hook up the docker logs to different logging drivers, see the official docker documentation . There are several solutions to application and log monitoring. For example Elastic Stack or Splunk. Contact us if you want help setting this up for your installation.","title":"Monitoring"},{"location":"meters/","text":"Meters # Meters we support Fiorentini # RSE/2001 LA # A NB-IoT Gas Meter. Uses an Italian companion standard to DLMS. Used in the first commercial rollout of NB-IoT Smart Meters in Sweden. Elster # EK 280 # Electronic volume conversion device with optional integrated communication module and configurable data interface. Protocol supported: LIS-200","title":"Meters"},{"location":"meters/#meters","text":"Meters we support","title":"Meters"},{"location":"meters/#fiorentini","text":"","title":"Fiorentini"},{"location":"meters/#rse2001-la","text":"A NB-IoT Gas Meter. Uses an Italian companion standard to DLMS. Used in the first commercial rollout of NB-IoT Smart Meters in Sweden.","title":"RSE/2001 LA"},{"location":"meters/#elster","text":"","title":"Elster"},{"location":"meters/#ek-280","text":"Electronic volume conversion device with optional integrated communication module and configurable data interface. Protocol supported: LIS-200","title":"EK 280"},{"location":"open_source/","text":"Open Source # We want Utilitarian to be a simple companion to our customers in their AMR operations. We provide documented interfaces and APIs to our services and messaging system. So you have the freedom of making use of the data as you see fit. For example if you need to make a special analytics service for some customers you can either get the data from the Utilitarian API or subscribe directly to it via the message broker. We provide some helpers to write your own integrations written in Python but since we are using AMQP and HTTP you can find implementations of those protocols in many programing languages and use the documentation in our helpers to speed up development of your own integrations in your language of choice. We also provide many libraries of the protocols we support as open source. Utilitarian Helpers # Utilitarian Queue Consumer # Check it out on GitHub: https://github.com/pwitab/utilitarian-queue-consumer The Utilitarian Queue Consumer is a micro framework to write consumers for the messages in Utilitarian. It gives you good default for consuming messages and producing new messages. AMR UM # Check it out on GitHub: https://github.com/pwitab/amr-um AMR UM (Unified Messaging for Automatic Meter Readings) is our attempt to have standard and well documented messaging framwork. In the repo you can find Python helpers to format the data and documentation on the different schemas used. Protocols # DLMS/COSEM # Check it out on GitHub: https://github.com/pwitab/dlms-cosem DLMS/COSEM (IEC 62056, EN13757-1) is the global standard for smart energy metering, control and management. It specifies an object-oriented data model, an application layer protocol and media-specific communication profiles.","title":"Open Source"},{"location":"open_source/#open-source","text":"We want Utilitarian to be a simple companion to our customers in their AMR operations. We provide documented interfaces and APIs to our services and messaging system. So you have the freedom of making use of the data as you see fit. For example if you need to make a special analytics service for some customers you can either get the data from the Utilitarian API or subscribe directly to it via the message broker. We provide some helpers to write your own integrations written in Python but since we are using AMQP and HTTP you can find implementations of those protocols in many programing languages and use the documentation in our helpers to speed up development of your own integrations in your language of choice. We also provide many libraries of the protocols we support as open source.","title":"Open Source"},{"location":"open_source/#utilitarian-helpers","text":"","title":"Utilitarian Helpers"},{"location":"open_source/#utilitarian-queue-consumer","text":"Check it out on GitHub: https://github.com/pwitab/utilitarian-queue-consumer The Utilitarian Queue Consumer is a micro framework to write consumers for the messages in Utilitarian. It gives you good default for consuming messages and producing new messages.","title":"Utilitarian Queue Consumer"},{"location":"open_source/#amr-um","text":"Check it out on GitHub: https://github.com/pwitab/amr-um AMR UM (Unified Messaging for Automatic Meter Readings) is our attempt to have standard and well documented messaging framwork. In the repo you can find Python helpers to format the data and documentation on the different schemas used.","title":"AMR UM"},{"location":"open_source/#protocols","text":"","title":"Protocols"},{"location":"open_source/#dlmscosem","text":"Check it out on GitHub: https://github.com/pwitab/dlms-cosem DLMS/COSEM (IEC 62056, EN13757-1) is the global standard for smart energy metering, control and management. It specifies an object-oriented data model, an application layer protocol and media-specific communication profiles.","title":"DLMS/COSEM"},{"location":"protocols/","text":"Protocols # The different protocols we support DLMS # TODO About dlms link to opensorce repo IEC 62056-21 # TODO About IEC 62056-21 Also used to be called IEC1107 link to open source code LIS-200 # TODO About LIS-200. Based on IEC62056-21 but allows for more freely defined objects. I-Flag # TODO Protocol from Itron. Link to open source repo MBus # TODO About Mbus Modbus # TODO General communication protocol for industry sector. Link to open source repo.","title":"Protocols"},{"location":"protocols/#protocols","text":"The different protocols we support","title":"Protocols"},{"location":"protocols/#dlms","text":"TODO About dlms link to opensorce repo","title":"DLMS"},{"location":"protocols/#iec-62056-21","text":"TODO About IEC 62056-21 Also used to be called IEC1107 link to open source code","title":"IEC 62056-21"},{"location":"protocols/#lis-200","text":"TODO About LIS-200. Based on IEC62056-21 but allows for more freely defined objects.","title":"LIS-200"},{"location":"protocols/#i-flag","text":"TODO Protocol from Itron. Link to open source repo","title":"I-Flag"},{"location":"protocols/#mbus","text":"TODO About Mbus","title":"MBus"},{"location":"protocols/#modbus","text":"TODO General communication protocol for industry sector. Link to open source repo.","title":"Modbus"},{"location":"providers/","text":"Provider specific implementations # Some metering equipment providers have well implemented integrations besides from pure metering protocols. This can involve HTTP Push, SMS or FTP uploads. To make life simpler we want to be able to provide integrations to provides with this kind of functionality and will work to implement as many of these as possible. Ongoing Development # We are currently not developing any provider specific implementations. If you are in need of an implementation please contact us .","title":"Providers"},{"location":"providers/#provider-specific-implementations","text":"Some metering equipment providers have well implemented integrations besides from pure metering protocols. This can involve HTTP Push, SMS or FTP uploads. To make life simpler we want to be able to provide integrations to provides with this kind of functionality and will work to implement as many of these as possible.","title":"Provider specific implementations"},{"location":"providers/#ongoing-development","text":"We are currently not developing any provider specific implementations. If you are in need of an implementation please contact us .","title":"Ongoing Development"},{"location":"pwit/","text":"Palmlund Wahlgren Innovative Technology AB # Palmlund Wahlgren Innovative Technology AB (PWIT AB) is an engineering firm focused on delivering solutions and consultation services within the fields of automation, measurement technology and IT. By combining our strengths we have landed in the field of Internet of Things where we have been able to manage projects and build devices and software within the smart metering segment. We have been working with Swedish utility companies in local projects and EU-level projects where we have designed and implemented solutions for Real Time AMR (Automatic Meter Readings) and Next Generation MDM (Meter Data Management) using NoSQL-databases. We have taken full responsibility for the whole metering chain. From implementing protocol interpreters on embedded devices and in the Cloud to enable real-time metering on older energy meters to meter data management and integration to legacy Enterprise systems such as SAP for billing. Utilitarian is the result of our desire to make AMR more simpler for the end user and put the data in focus instead of the means to collect the data. We have used all our experience in the field to deliver a solution that can fit any size and type of utility company. Learn more about us","title":"PWIT AB"},{"location":"pwit/#palmlund-wahlgren-innovative-technology-ab","text":"Palmlund Wahlgren Innovative Technology AB (PWIT AB) is an engineering firm focused on delivering solutions and consultation services within the fields of automation, measurement technology and IT. By combining our strengths we have landed in the field of Internet of Things where we have been able to manage projects and build devices and software within the smart metering segment. We have been working with Swedish utility companies in local projects and EU-level projects where we have designed and implemented solutions for Real Time AMR (Automatic Meter Readings) and Next Generation MDM (Meter Data Management) using NoSQL-databases. We have taken full responsibility for the whole metering chain. From implementing protocol interpreters on embedded devices and in the Cloud to enable real-time metering on older energy meters to meter data management and integration to legacy Enterprise systems such as SAP for billing. Utilitarian is the result of our desire to make AMR more simpler for the end user and put the data in focus instead of the means to collect the data. We have used all our experience in the field to deliver a solution that can fit any size and type of utility company. Learn more about us","title":"Palmlund Wahlgren Innovative Technology AB"},{"location":"using_https_on_api/","text":"Run Utilitarian API under HTTPS # The main application does not provide any means to run under HTTPS. This is done via a reverse proxy like NginX or HAProxy. Having a reverse proxy also simplifies load balancing if you need to scale up the API. You can run it as a stand alone service or run it as docker container. We leave it up to the customer to define the way they want to terminate SSL/TLS and handle load balancing but will of course provide help if needed. Settings in Utilitarian API if running under HTTPS: # TODO...","title":"Use HTTPS"},{"location":"using_https_on_api/#run-utilitarian-api-under-https","text":"The main application does not provide any means to run under HTTPS. This is done via a reverse proxy like NginX or HAProxy. Having a reverse proxy also simplifies load balancing if you need to scale up the API. You can run it as a stand alone service or run it as docker container. We leave it up to the customer to define the way they want to terminate SSL/TLS and handle load balancing but will of course provide help if needed.","title":"Run Utilitarian API under HTTPS"},{"location":"using_https_on_api/#settings-in-utilitarian-api-if-running-under-https","text":"TODO...","title":"Settings in Utilitarian API if running under HTTPS:"}]}